\begin{minted}{cpp}
/*** （静态）点分治 ***/
void Find1(int x,int fa)
{
    siz[x]=1,subsiz++;
    for(int i=hea[x];i;i=nex[i]) if(!used[ver[i]] && ver[i]!=fa)
        Find1(ver[i],x),siz[x]+=siz[ver[i]];
}
void Find2(int x,int fa)
{
    bool isrt=true;
    for(int i=hea[x];i;i=nex[i]) if(!used[ver[i]] && ver[i]!=fa)
    {
        Find2(ver[i],x);
        if((siz[ver[i]]<<1)>subsiz) isrt=false;
    }
    if(((subsiz-siz[x])<<1)>subsiz) isrt=false;
    if(isrt) rt=x;
}
void solve(int x)
{
    subsiz=0,Find1(x,0),Find2(x,0);
    // 处理和 rt 有关的答案
    used[rt]=true;
    for(int i=hea[rt];i;i=nex[i]) if(!used[ver[i]]) solve(ver[i]);
}
\end{minted}

熟知序列分治的过程是选取恰当的分治点并考虑所有跨过分治点的区间。而树分治的过程也是类似的，以点分治为例，每一次选择当前联通块的重心作为分治点，然后考虑所有跨越分治点的路径，并对分割出的联通块递归。

若要处理树上邻域问题，可以考虑建出点分树。处理点 x 的询问时，只需考虑 x 在点分树上到根的路径，每一次加上除开 x 所在子树的答案即可。

\inputminted{cpp}{src/data structure/tree-divide.cpp}